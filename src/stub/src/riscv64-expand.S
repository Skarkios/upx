/*
;  riscv64-expand.S -- decompressors for riscv64
;
;  This file is part of the UPX executable compressor.
;
;  Copyright (C) 1996-2021 Markus Franz Xaver Johannes Oberhumer
;  Copyright (C) 1996-2021 Laszlo Molnar
;  Copyright (C) 2000-2025 John F. Reiser
;  All Rights Reserved.
;
;  UPX and the UCL library are free software; you can redistribute them
;  and/or modify them under the terms of the GNU General Public License as
;  published by the Free Software Foundation; either version 2 of
;  the License, or (at your option) any later version.
;
;  This program is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this program; see the file COPYING.
;  If not, write to the Free Software Foundation, Inc.,
;  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
;
;  Markus F.X.J. Oberhumer              Laszlo Molnar
;  <markus@oberhumer.com>               <ezerotven+github@gmail.com>
;
;  John F. Reiser
;  <jreiser@users.sourceforge.net>
;
*/

NBPW = 8
#include "arch/riscv/64/macros.S"
#include "arch/riscv/64/regs.h"

.macro call  subr; jal  \subr; .endm
.macro callr subr; jalr \subr; .endm

  section EXP_HEAD

sz_unc= 0
sz_cpr= 4
b_method= 8
b_ftid=   9
b_cto8=  10
b_extra= 11
sz_binfo= 12

f_expand: .globl f_expand // f_expand(b_info *, dst, &dstlen)
// Supervisor for de-compression, un-filter, and sync_cache
// Input to supervisor:
#define fx_src arg1
#define fx_dst arg2
#define fx_dstlen arg3
  ebreak  // f_expand
    PUSH2 s0,s1  // MATCH_93  ABI callee saved
    PUSH4 fx_src,fx_dst,fx_dstlen,ra  // MATCH_95 params to unfilter and sync_cache

// Input to de-compressor:
#define meth arg5
    lbu meth,b_method(fx_src)
    mv arg4,fx_dstlen
    mv arg3,fx_dst
    lw arg2,sz_cpr(fx_src)
    addi arg1,fx_src,sz_binfo
        // fall into daisy-chain of decompressors

#include "riscv64-getbit.h"
    jal x5,decompress  # x5= &getbit
#include "riscv64-getbit.S"

decompress:  // (src *, cpr_len, dst *, &dstlen);

#define NO_METHOD_CHECK 1  /* subsumed here by daisy chain */

#define M_NRV2B_LE32    2
#define M_NRV2B_8    3
#define M_NRV2D_LE32    5
#define M_NRV2D_8    6
#define M_NRV2E_LE32    8
#define M_NRV2E_8    9
#define M_CL1B_LE32     11
#define M_LZMA          14

  section NRV2E
    li t0,M_NRV2E_LE32; bne meth,t0,not_nrv2e
    mv dst,arg3
    mv src,arg1
//NYI #include "arch/arm64/v8/nrv2e_d.S"
not_nrv2e:

  section NRV2D
    li t0,M_NRV2D_LE32; bne meth,t0,not_nrv2d
    mv dst,arg3
    mv src,arg1
//NYI #include "arch/arm64/v8/nrv2d_d.S"
not_nrv2d:

  section NRV2B
    li t0,M_NRV2B_LE32; bne meth,t0,not_nrv2b
    mv dst,arg3
    mv src,arg1
#include "arch/riscv/64/nrv2b_d.S"
not_nrv2b:

  section LZMA_DAISY
    li t0,M_LZMA; bne meth,t0,not_lzma
//NYI #include "arch/arm64/v8/lzma_d.S"
not_lzma:

  section EXP_TAIL
// Fall through: daisy chain had no matching method
    ebreak  // EXP_TAIL
        li a0,-1
        mv a1,meth

  .globl eof

eof_lzma: .globl eof_lzma
    ebreak  // eof_lzma
        POP4 x2,x3, fp,ra   // MATCH_94  x2= orig_dst; x3= plen_dst
        ret

eof_n2b:
eof_n2d:
eof_n2e:
    POP4 fx_src,fx_dst,fx_dstlen,ra  // MATCH_95  fx_src,fx_dst,fx_dstlen,ra
    mv  s0,fx_dst
    sub s1,dst,fx_dst  # length generated by de-compress
#undef fx_dst
    sd  s1,0(fx_dstlen)  # register s1 needed by unfiler and icache sync
#undef fx_dstlen
    sub src,src,fx_src  # check input consumed

    ld  val,0(fx_src)  # &b_info
#undef fx_src
    lbu arg3,b_method(val)  # filter
    beqz arg3,no_unf
      mv arg1,s0
      mv arg2,s1  // actual dstlen
//NYI #include "arch/arm64/v8/bxx.S"  // unfilter code; args in registers, fall-through return
no_unf:
    mv arg1,s0
    mv arg2,s1
//NYI sync_cache; in macros.S ?
//  fence.i  # not supported by Linux?
uncfail:
    POP2 s0,s1  # MATCH_93  ABI
    mv rv,src  # return value
    ret

// WINDOWS_BACK compatibility seems to be broken
// if POP3 replaces POP2+POP1 (MATCH_92, MATCH_91)
#if 0  //{ Windows?
//#define srclim  a7
//        POP2 a3,a4   // MATCH_92  r3= orig_dst; r4= plen_dst
//        SUB2 src,srclim   // 0 if actual src length equals expected length
//        SUB2 dst,a3   // actual dst length
//        sw dst,(a4)
//        POP1 ra  // MATCH_91
//        ret
#endif  //}

upx_mmap_and_fd: .globl upx_mmap_and_fd
    // UMF_LINUX goes here

#if 0  // {BUGGY
//copy:  // In: len, dst, dispq;  Out: 0==len, dst, dispq;  trashes %rax, %rdx
//        add rax,dst,disp; li t0,5; sgtu t0,t0,len  // <=3 is forced
//        lbu rdx,0(rax); bnez t0,copy1  // <=5 for better branch predict
//        li t0,-4; sgtu t0,disp,t0; bnez t0,copy1  // 4-byte chunks would overlap
//        addi len,len,-4  // adjust for termination cases
//        add t0,len,dst
//copy4:
//        lwu rdx,0(rax); addi rax,rax,4
//        sw  rdx,0(dst); addi dst,dst,4; bgeu dst,len,copy4
//        addi len,len,4; lbu rdx,0(rax); beqz len,copy0
//copy1:
//        addi rax,rax,1; lbu rdx,0(dst); addi len,len,-1
//            lbu rdx,0(rax)
//                addi dst,dst,1;  bnez len,copy1
//copy0:
//        ret
#endif  //}

